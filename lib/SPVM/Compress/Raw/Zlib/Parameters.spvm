# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Compress::Raw::Zlib::Parameters {
  version_from Compress::Raw::Zlib;
  
  use Hash;
  use Fn;
  use Compress::Raw::Zlib::Constant as CZLIB;
  use Re;
  
  # Undocumented Field
  has Error : string;
  
  has Got : Hash of int[];
  
  # Class Methods
  static method new : Compress::Raw::Zlib::Parameters () {
    
    my $self = new Compress::Raw::Zlib::Parameters;
    
    $self->{Got} = Hash->new;
    
    return $self;
  }
  
  static method ParseParameters : Compress::Raw::Zlib::Parameters ($default : object[] = undef, $entered : object[] = undef) {
    
    my $self = Compress::Raw::Zlib::Parameters->new;
    $self->parse($default, $entered);
    return $self;
  }
  
  # Instance Methods
  method parse : void ($default : object[] = undef, $entered : object[] = undef) {
    
  }
  
  private method _checkType : int ($key : string, $value_ref : object[], $type : int, $validate : int, $output_ref : object[]) {
  
    my $value = $value_ref->[0] ;
    
    if ($type & CZLIB->Parse_any) {
      $output_ref->[0] = $value;
      return 1;
    }
    elsif ($type & CZLIB->Parse_unsigned) {
      if ($validate && ! $value) {
        die "Parameter '$key' must be an unsigned int, got 'undef'";
      }
      
      if ($validate && !Re->m($value, "^\d+$")) {
        die "Parameter '$key' must be an unsigned int.";
      }
      
      $output_ref->[0] = $value ? (Int)(int)$value : (Int)0;
      
      return 1;
    }
    elsif ($type & CZLIB->Parse_signed) {
      if ($validate && ! $value) {
        die "Parameter '$key' must be a signed int, got 'undef'";
      }
      
      if ($validate && !Re->m($value, "^-?\d+$")) {
        die "Parameter '$key' must be a signed int.";
      }
      
      $output_ref->[0] = $value ? (Int)(int)$value : (Int)0;
      
      return 1;
    }
    elsif ($type & CZLIB->Parse_boolean) {
      if ($validate && $value && !Re->m($value, "^\d*$")) {
        die "Parameter '$key' must be an int.";
      }
      
      $output_ref->[0] =  $value ? (Int)((int)$value != 0) : (Int)0 ;
      return 1;
    }
    
    $output_ref->[0] = $value;
    
    return 1;
  }
  
  method parsed : int ($name : string) {
    
    my $Got = $self->{Got};
    
    my $param = (int[])$Got->get(Fn->lc($name));
    
    unless ($param) {
      return 0;
    }
    
    return $param->[CZLIB->OFF_PARSED] ;
  }
  
  method value : object ($name : string) {
    
    my $Got = $self->{Got};
    
    my $param = (int[])$Got->get(Fn->lc($name));
    
    unless ($param) {
      return undef;
    }
    
    return $param->[CZLIB->OFF_FIXED];
  }
  
  method set_value : void ($name : string, $value : object) {
    
    my $Got = $self->{Got};
    
    my $param = (object[])$Got->get(Fn->lc($name));
    
    unless ($param) {
      $param = new object[6];
    }
    
    $param->[CZLIB->OFF_PARSED] = 1;
    $param->[CZLIB->OFF_DEFAULT] = $value;
    $param->[CZLIB->OFF_FIXED] = $value;
  }

}

__END__

sub Compress::Raw::Zlib::Parameters::parse
{
    my $self = shift ;

    my $default = shift ;

    my $got = $self->{Got} ;
    my $firstTime = keys %{ $got } == 0 ;

    my (@Bad) ;
    my @entered = () ;

    # Allow the options to be passed as a hash reference or
    # as the complete hash.
    if (@_ == 0) {
        @entered = () ;
    }
    elsif (@_ == 1) {
        my $href = $_[0] ;
        return $self->setError("Expected even number of parameters, got 1")
            if ! defined $href or ! ref $href or ref $href ne "HASH" ;

        foreach my $key (keys %$href) {
            push @entered, $key ;
            push @entered, \$href->{$key} ;
        }
    }
    else {
        my $count = @_;
        return $self->setError("Expected even number of parameters, got $count")
            if $count % 2 != 0 ;

        for my $i (0.. $count / 2 - 1) {
            push @entered, $_[2* $i] ;
            push @entered, \$_[2* $i+1] ;
        }
    }


    while (my ($key, $v) = each %$default)
    {
        croak "need 4 params [@$v]"
            if @$v != 4 ;

        my ($first_only, $sticky, $type, $value) = @$v ;
        my $x ;
        $self->_checkType($key, \$value, $type, 0, \$x)
            or return undef ;

        $key = lc $key;

        if ($firstTime || ! $sticky) {
            $got->{$key} = [0, $type, $value, $x, $first_only, $sticky] ;
        }

        $got->{$key}[OFF_PARSED] = 0 ;
    }

    for my $i (0.. @entered / 2 - 1) {
        my $key = $entered[2* $i] ;
        my $value = $entered[2* $i+1] ;

        #print "Key [$key] Value [$value]" ;
        #print defined $$value ? "[$$value]\n" : "[undef]\n";

        $key =~ s/^-// ;
        my $canonkey = lc $key;

        if ($got->{$canonkey} && ($firstTime ||
                                  ! $got->{$canonkey}[OFF_FIRST_ONLY]  ))
        {
            my $type = $got->{$canonkey}[OFF_TYPE] ;
            my $s ;
            $self->_checkType($key, $value, $type, 1, \$s)
                or return undef ;
            #$value = $$value unless $type & Parse_store_ref ;
            $value = $$value ;
            $got->{$canonkey} = [1, $type, $value, $s] ;
        }
        else
          { push (@Bad, $key) }
    }

    if (@Bad) {
        my ($bad) = join(", ", @Bad) ;
        return $self->setError("unknown key value(s) @Bad") ;
    }

    return 1;
}
