# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Compress::Raw::Zlib {
  version "0.001";
  
  use Resource::Zlib;
  use Compress::Raw::Zlib::Constant;
  use Compress::Raw::Zlib::Deflate;
  use Compress::Raw::Zlib::Inflate;
}

__END__

MODULE = Compress::Raw::Zlib PACKAGE = Compress::Raw::Zlib        PREFIX = Zip_

REQUIRE:	1.924
PROTOTYPES:	DISABLE

INCLUDE: constants.xs

BOOT:
#if ! USE_ZLIB_NG
    /* Check this version of zlib is == 1 */
    if (CRZ_zlibVersion()[0] != '1')
        croak("Compress::Raw::Zlib needs zlib version 1.x\n") ;
#endif

    {
        /* Create the $os_code scalar */
        SV * os_code_sv = perl_get_sv("Compress::Raw::Zlib::gzip_os_code", GV_ADDMULTI) ;
        sv_setiv(os_code_sv, GZIP_OS_CODE) ;
    }

    {
        /* BUILD_ZLIB  */
        SV * os_code_sv = perl_get_sv("Compress::Raw::Zlib::BUILD_ZLIB", GV_ADDMULTI) ;
        sv_setiv(os_code_sv, Perl_crz_BUILD_ZLIB) ;
    }

#define Zip_zlib_version()	(const char*)CRZ_zlib_version()
const char*
Zip_zlib_version()

const char*
zlibng_version()

#define Zip_is_zlib_native()	(! (HAVE_ZLIB_NG_NATIVE || HAVE_ZLIB_NG_COMPAT))
bool
Zip_is_zlib_native()

#define Zip_is_zlibng_native()	(bool)HAVE_ZLIB_NG_NATIVE
bool
Zip_is_zlibng_native()

#define Zip_is_zlibng_compat()	(bool)HAVE_ZLIB_NG_COMPAT
bool
Zip_is_zlibng_compat()

#define Zip_is_zlibng()	(bool)(HAVE_ZLIB_NG_NATIVE || HAVE_ZLIB_NG_COMPAT)
bool
Zip_is_zlibng()

unsigned
ZLIB_VERNUM()
    CODE:
#ifdef ZLIB_VERNUM
        RETVAL = ZLIB_VERNUM ;
#elif USE_ZLIB_NG
        RETVAL = 0 ;
#else
        /* 1.1.4 => 0x1140 */
        RETVAL  = (CRZ_ZLIB_VERSION[0] - '0') << 12 ;
        RETVAL += (CRZ_ZLIB_VERSION[2] - '0') <<  8 ;
        RETVAL += (CRZ_ZLIB_VERSION[4] - '0') <<  4 ;
        if (strlen(CRZ_ZLIB_VERSION) > 5)
            RETVAL += (CRZ_ZLIB_VERSION[6] - '0')  ;
#endif
    OUTPUT:
        RETVAL


#ifndef AT_LEAST_ZLIB_1_2_1
#  define Zip_zlibCompileFlags  0
#else
#  define Zip_zlibCompileFlags  CRZ_zlibCompileFlags
#endif
uLong
Zip_zlibCompileFlags()

const char*
ZLIBNG_VER_STATUS()
    CODE:
#ifdef ZLIBNG_VER_STATUS
        RETVAL = STRINGIFY(ZLIBNG_VER_STATUS);
#else
        RETVAL = "0";
#endif
    OUTPUT:
        RETVAL

MODULE = Compress::Raw::Zlib	PACKAGE = Compress::Raw::Zlib	PREFIX = Zip_

#define Zip_adler32(buf, adler) CRZ_adler32(adler, buf, (uInt)len)

uLong
Zip_adler32(buf, adler=CRZ_adlerInitial)
        uLong    adler = NO_INIT
        STRLEN   len = NO_INIT
        Bytef *  buf = NO_INIT
	SV *	 sv = ST(0) ;
	INIT:
    	/* If the buffer is a reference, dereference it */
	sv = deRef(sv, "adler32") ;
#ifdef UTF8_AVAILABLE
    if (DO_UTF8(sv) && !sv_utf8_downgrade(sv, 1))
         croak("Wide character in Compress::Raw::Zlib::adler32");
#endif
	buf = (Byte*)SvPVbyte(sv, len) ;

	if (items < 2)
	  adler = CRZ_adlerInitial;
	else if (SvOK(ST(1)))
	  adler = SvUV(ST(1)) ;
	else
	  adler = CRZ_adlerInitial;
    OUTPUT:
        RETVAL

#define Zip_crc32(buf, crc, offset) CRZ_crc32(crc, buf+offset, (uInt)len-offset)

uLong
Zip_crc32(buf, crc=CRZ_crcInitial, offset=0)
        uLong    crc = NO_INIT
        STRLEN   len = NO_INIT
        Bytef *  buf = NO_INIT
        STRLEN   offset
	SV *	 sv = ST(0) ;
	INIT:
    	/* If the buffer is a reference, dereference it */
	sv = deRef(sv, "crc32") ;
#ifdef UTF8_AVAILABLE
    if (DO_UTF8(sv) && !sv_utf8_downgrade(sv, 1))
         croak("Wide character in Compress::Raw::Zlib::crc32");
#endif
	buf = (Byte*)SvPVbyte(sv, len) ;

	if (offset > len)
	  croak("Offset out of range in Compress::Raw::Zlib::crc32");

	if (items < 2)
	  crc = CRZ_crcInitial;
	else if (SvOK(ST(1)))
	  crc = SvUV(ST(1)) ;
	else
	  crc = CRZ_crcInitial;

uLong
crc32_combine(crc1, crc2, len2)
        uLong    crc1
        uLong    crc2
        z_off_t   len2
	CODE:
#ifndef AT_LEAST_ZLIB_1_2_2_1
        crc1 = crc1; crc2 = crc2 ; len2 = len2; /* Silence -Wall */
        croak("crc32_combine needs zlib 1.2.3 or better");
#else
        RETVAL = CRZ_crc32_combine(crc1, crc2, len2);
#endif
    OUTPUT:
        RETVAL


uLong
adler32_combine(adler1, adler2, len2)
        uLong    adler1
        uLong    adler2
        z_off_t   len2
	CODE:
#ifndef AT_LEAST_ZLIB_1_2_2_1
        adler1 = adler1; adler2 = adler2 ; len2 = len2; /* Silence -Wall */
        croak("adler32_combine needs zlib 1.2.3 or better");
#else
        RETVAL = CRZ_adler32_combine(adler1, adler2, len2);
#endif
    OUTPUT:
        RETVAL


MODULE = Compress::Raw::Zlib PACKAGE = Compress::Raw::Zlib

void
_deflateInit(flags,level, method, windowBits, memLevel, strategy, bufsize, dictionary)
    int flags
    int	level
    int method
    int windowBits
    int memLevel
    int strategy
    uLong bufsize
    SV* dictionary
  PPCODE:
    int err ;
    deflateStream s ;

    if (trace)
        warn("in _deflateInit(level=%d, method=%d, windowBits=%d, memLevel=%d, strategy=%d, bufsize=%ld dictionary=%p)\n",
	level, method, windowBits, memLevel, strategy, bufsize, dictionary) ;
    if ((s = InitStream() )) {

        s->Level      = level;
        s->Method     = method;
        s->WindowBits = windowBits;
        s->MemLevel   = memLevel;
        s->Strategy   = strategy;

        err = CRZ_deflateInit2(&(s->stream), level,
			   method, windowBits, memLevel, strategy);

        if (trace) {
            warn(" _deflateInit2 returned %d (state %p)\n", err, s);
            DispStream(s, "INIT");
        }

	/* Check if a dictionary has been specified */
	SvGETMAGIC(dictionary);
	if (err == Z_OK && SvPOK(dictionary) && SvCUR(dictionary)) {
#ifdef UTF8_AVAILABLE
            if (DO_UTF8(dictionary) && !sv_utf8_downgrade(dictionary, 1))
                croak("Wide character in Compress::Raw::Zlib::Deflate::new dicrionary parameter");
#endif
	    err = CRZ_deflateSetDictionary(&(s->stream), (const Bytef*) SvPVX(dictionary), SvCUR(dictionary)) ;
        if (trace)
            warn("deflateSetDictionary returned %d\n", err);
	    s->dict_adler = s->stream.adler ;
	}

        if (err != Z_OK) {
            Safefree(s) ;
            s = NULL ;
	}
	else
	    PostInitStream(s, flags, bufsize, windowBits) ;

    }
    else
        err = Z_MEM_ERROR ;

    {
        SV* obj = sv_setref_pv(sv_newmortal(),
            "Compress::Raw::Zlib::deflateStream", (void*)s);
        XPUSHs(obj);
    }
    if (GIMME_V == G_ARRAY) {
        SV * sv = sv_2mortal(newSViv(err)) ;
	setDUALstatus(sv, err);
        XPUSHs(sv) ;
    }

void
_inflateInit(flags, windowBits, bufsize, dictionary)
    int flags
    int windowBits
    uLong bufsize
    SV * dictionary
  ALIAS:
    _inflateScanInit = 1
  PPCODE:

    int err = Z_OK ;
    inflateStream s ;
#ifndef MAGIC_APPEND
    if (ix == 1)
        croak("inflateScanInit needs zlib 1.2.1 or better");
#endif
    if (trace)
        warn("in _inflateInit(windowBits=%d, bufsize=%lu, dictionary=%lu\n",
                windowBits, bufsize, (unsigned long)SvCUR(dictionary)) ;
    if ((s = InitStream() )) {

        s->WindowBits = windowBits;

        err = CRZ_inflateInit2(&(s->stream), windowBits);
        if (err != Z_OK) {
            Safefree(s) ;
            s = NULL ;
	}
	else if (sv_len(dictionary)) {
#ifdef AT_LEAST_ZLIB_1_2_2_1
        /* Zlib 1.2.2.1 or better allows a dictionary with raw inflate */
        if (s->WindowBits < 0) {
            STRLEN dlen;
            const Bytef* b = (const Bytef*)SvPVbyte(dictionary, dlen);
            err = CRZ_inflateSetDictionary(&(s->stream),
                b, dlen);
            if (err != Z_OK) {
                Safefree(s) ;
                s = NULL ;
            }
        }
        else
#endif
            /* Dictionary specified - take a copy for use in inflate */
	    s->dictionary = newSVsv(dictionary) ;
	}
	if (s) {
	    PostInitStream(s, flags, bufsize, windowBits) ;
#ifdef MAGIC_APPEND
            if (ix == 1)
            {
                s->window = (unsigned char *)safemalloc(WINDOW_SIZE);
            }
#endif
        }
    }
    else
	err = Z_MEM_ERROR ;

    {
        SV* obj = sv_setref_pv(sv_newmortal(),
                   ix == 1
                   ? "Compress::Raw::Zlib::inflateScanStream"
                   :  "Compress::Raw::Zlib::inflateStream",
                   (void*)s);
        XPUSHs(obj);
    }
    if (GIMME_V == G_ARRAY) {
        SV * sv = sv_2mortal(newSViv(err)) ;
	setDUALstatus(sv, err);
        XPUSHs(sv) ;
    }



